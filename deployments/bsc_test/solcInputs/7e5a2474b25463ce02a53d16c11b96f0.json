{
  "language": "Solidity",
  "sources": {
    "contracts/Marketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Marketplace {\n    event UserCreated(\n        address indexed userAddress,\n        uint256 userId,\n        string username,\n        uint8 accountType\n    );\n    event UserUpdated(\n        address indexed userAddress,\n        uint256 userId,\n        string username,\n        uint8 accountType\n    );\n    event StoreCreated(\n        address indexed sellerAddress,\n        uint256 storeId,\n        string storeName,\n        int256 latitude,\n        int256 longitude\n    );\n\n    event OfferAccepted(\n        uint256 indexed offerId,\n        address indexed buyerAddress,\n        bool isAccepted\n    );\n    event RequestCreated(\n        uint256 indexed requestId,\n        address indexed buyerAddress,\n        string requestName,\n        int256 latitude,\n        int256 longitude,\n        string[] images,\n        uint8 lifecycle,\n        string description,\n        uint256 buyerId,\n        uint256[] sellerIds,\n        int256 sellersPriceQuote,\n        uint256 lockedSellerId,\n        uint256 createdAt,\n        uint256 updatedAt\n    );\n\n    event OfferCreated(\n        uint256 indexed offerId,\n        address indexed sellerAddress,\n        string storeName,\n        int256 price,\n        uint256 requestId,\n        string[] images,\n        uint256 sellerId,\n        uint256[] sellerIds\n    );\n\n    event RequestAccepted(\n        uint256 indexed requestId,\n        uint256 indexed offerId,\n        uint256 indexed sellerId,\n        uint256 updatedAt,\n        int256 sellersPriceQuote\n    );\n\n    event OfferRemoved(uint256 indexed offerId, address indexed sellerAddress);\n\n    enum AccountType {\n        BUYER,\n        SELLER\n    }\n    enum RequestLifecycle {\n        PENDING,\n        ACCEPTED_BY_SELLER,\n        ACCEPTED_BY_BUYER,\n        REQUEST_LOCKED,\n        COMPLETED\n    }\n\n    struct Location {\n        int256 latitude;\n        int256 longitude;\n    }\n\n    struct Store {\n        uint256 id;\n        string name;\n        string description;\n        string phone;\n        Location location;\n    }\n\n    mapping(address => mapping(uint256 => Store)) public userStores;\n    mapping(address => uint256[]) public userStoreIds;\n\n    struct User {\n        uint256 id;\n        string username;\n        string phone;\n        Location location;\n        uint256 createdAt;\n        uint256 updatedAt;\n        AccountType accountType;\n    }\n\n    struct Request {\n        uint256 id;\n        string name;\n        uint256 buyerId;\n        int256 sellersPriceQuote;\n        uint256[] sellerIds;\n        uint256[] offerIds;\n        uint256 lockedSellerId;\n        string description;\n        string[] images;\n        uint256 createdAt;\n        RequestLifecycle lifecycle;\n        Location location;\n        uint256 updatedAt;\n    }\n\n    struct Offer {\n        uint256 id;\n        int256 price;\n        string[] images;\n        uint256 requestId;\n        string storeName;\n        uint256 sellerId;\n        bool isAccepted;\n        uint256 createdAt;\n        uint256 updatedAt;\n    }\n\n    // Custom errors with Marketplace__ prefix\n    error Marketplace__OnlySellersAllowed();\n    error Marketplace__UnauthorizedBuyer();\n    error Marketplace__OnlyBuyersAllowed();\n    error Marketplace__OfferAlreadyAccepted();\n    error Marketplace__InvalidAccountType();\n    error Marketplace__OfferAlreadyExists();\n    error Marketplace__UnauthorizedRemoval();\n    error Marketplace__OfferNotRemovable();\n    error Marketplace__IndexOutOfBounds();\n    error Marketplace__RequestLocked();\n    error Marketplace_InvalidUser();\n    error Marketplace_UserAlreadyExists();\n\n    mapping(address => User) public users;\n    mapping(uint256 => Request) public requests;\n    mapping(uint256 => Offer) public offers;\n\n    uint256 private _userCounter;\n    uint256 private _storeCounter;\n    uint256 private _requestCounter;\n    uint256 private _offerCounter;\n\n    uint256 constant TIME_TO_LOCK = 900;\n\n    function createUser(\n        string memory _username,\n        string memory _phone,\n        int256 _latitude,\n        int256 _longitude,\n        AccountType _accountType\n    ) public {\n        User storage user = users[msg.sender];\n        if (user.id != 0) {\n            revert Marketplace_UserAlreadyExists();\n        }\n\n        if (\n            _accountType != AccountType.BUYER &&\n            _accountType != AccountType.SELLER\n        ) {\n            revert Marketplace__InvalidAccountType();\n        }\n\n        Location memory userLocation = Location(_latitude, _longitude);\n\n        _userCounter++;\n        uint256 userId = _userCounter;\n\n        users[msg.sender] = User(\n            userId,\n            _username,\n            _phone,\n            userLocation,\n            block.timestamp,\n            block.timestamp,\n            _accountType\n        );\n\n        emit UserCreated(msg.sender, userId, _username, uint8(_accountType));\n    }\n\n    function updateUser(\n        string memory _username,\n        string memory _phone,\n        int256 _latitude,\n        int256 _longitude,\n        AccountType _accountType\n    ) public {\n        User storage user = users[msg.sender];\n\n        if (user.id == 0) {\n            revert Marketplace_InvalidUser();\n        }\n\n        // Update user information\n        user.username = _username;\n        user.phone = _phone;\n        user.location = Location(_latitude, _longitude);\n        user.updatedAt = block.timestamp;\n        user.accountType = _accountType;\n\n        emit UserUpdated(\n            msg.sender,\n            user.id,\n            _username,\n            uint8(user.accountType)\n        );\n    }\n\n    function createStore(\n        string memory _name,\n        string memory _description,\n        string memory _phone,\n        int256 _latitude,\n        int256 _longitude\n    ) public {\n        if (users[msg.sender].accountType != AccountType.SELLER) {\n            revert Marketplace__OnlySellersAllowed();\n        }\n\n        Location memory storeLocation = Location(_latitude, _longitude);\n\n        _storeCounter++;\n        uint256 storeId = _storeCounter;\n\n        Store memory newStore = Store(\n            storeId,\n            _name,\n            _description,\n            _phone,\n            storeLocation\n        );\n        userStores[msg.sender][storeId] = newStore;\n        userStoreIds[msg.sender].push(storeId);\n        emit StoreCreated(msg.sender, storeId, _name, _latitude, _longitude);\n    }\n\n    function createRequest(\n        string memory _name,\n        string memory _description,\n        string[] memory _images,\n        int256 _latitude,\n        int256 _longitude\n    ) public {\n        if (users[msg.sender].accountType != AccountType.BUYER) {\n            revert Marketplace__OnlyBuyersAllowed();\n        }\n\n        Location memory requestLocation = Location(_latitude, _longitude);\n\n        _requestCounter++;\n        uint256 requestId = _requestCounter;\n\n        Request memory newRequest = Request(\n            requestId,\n            _name,\n            users[msg.sender].id,\n            0,\n            new uint256[](0),\n            new uint256[](0),\n            0,\n            _description,\n            _images,\n            block.timestamp,\n            RequestLifecycle.PENDING,\n            requestLocation,\n            block.timestamp\n        );\n        requests[requestId] = newRequest;\n        emit RequestCreated(\n            requestId,\n            msg.sender,\n            _name,\n            _latitude,\n            _longitude,\n            _images,\n            uint8(RequestLifecycle.PENDING),\n            _description,\n            users[msg.sender].id,\n            new uint256[](0),\n            0,\n            0,\n            block.timestamp,\n            block.timestamp\n        );\n    }\n\n    function createOffer(\n        int256 _price,\n        string[] memory _images,\n        uint256 _requestId,\n        string memory _storeName\n    ) public {\n        if (users[msg.sender].accountType != AccountType.SELLER) {\n            revert Marketplace__OnlySellersAllowed();\n        }\n\n        Request storage request = requests[_requestId];\n\n        if (\n            block.timestamp > request.updatedAt + TIME_TO_LOCK &&\n            request.lifecycle == RequestLifecycle.ACCEPTED_BY_BUYER\n        ) {\n            revert Marketplace__RequestLocked();\n        }\n\n        _offerCounter++;\n        uint256 offerId = _offerCounter;\n\n        Offer memory newOffer = Offer(\n            offerId,\n            _price,\n            _images,\n            _requestId,\n            _storeName,\n            users[msg.sender].id,\n            false,\n            block.timestamp,\n            block.timestamp\n        );\n        offers[offerId] = newOffer;\n        request.sellerIds.push(newOffer.sellerId);\n\n        emit OfferCreated(\n            offerId,\n            msg.sender,\n            _storeName,\n            _price,\n            _requestId,\n            _images,\n            users[msg.sender].id,\n            request.sellerIds\n        );\n        // mapping(address => mapping(uint256 => Offer)) offers;\n    }\n\n    function acceptOffer(uint256 _offerId) public {\n        Offer storage offer = offers[_offerId];\n        Request storage request = requests[offer.requestId];\n\n        if (users[msg.sender].accountType != AccountType.BUYER) {\n            revert Marketplace__OnlyBuyersAllowed();\n        }\n\n        if (requests[offer.requestId].buyerId != users[msg.sender].id) {\n            revert Marketplace__UnauthorizedBuyer();\n        }\n\n        if (offer.isAccepted) {\n            revert Marketplace__OfferAlreadyAccepted();\n        }\n\n        if (\n            block.timestamp > request.updatedAt + TIME_TO_LOCK &&\n            request.lifecycle == RequestLifecycle.ACCEPTED_BY_BUYER\n        ) {\n            revert Marketplace__RequestLocked();\n        }\n\n        for (uint i = 0; i < request.offerIds.length; i++) {\n            uint256 offerId = request.offerIds[i];\n            Offer storage previousOffer = offers[offerId];\n            previousOffer.isAccepted = false;\n            emit OfferAccepted(previousOffer.id, msg.sender, false);\n        }\n\n        offer.isAccepted = true;\n        offer.updatedAt = block.timestamp;\n        request.offerIds.push(offer.id);\n        request.lockedSellerId = offer.sellerId;\n        request.sellersPriceQuote = offer.price;\n        request.lifecycle = RequestLifecycle.ACCEPTED_BY_BUYER;\n        request.updatedAt = block.timestamp;\n\n        emit RequestAccepted(\n            request.id,\n            offer.id,\n            offer.sellerId,\n            request.updatedAt,\n            request.sellersPriceQuote\n        );\n        emit OfferAccepted(offer.id, msg.sender, true);\n    }\n\n    function removeOffer(uint256 _offerId) public {\n        Offer storage offer = offers[_offerId];\n        Request storage request = requests[offer.requestId];\n\n        // Check if the sender is the seller who created the offer\n        if (offer.sellerId != users[msg.sender].id) {\n            revert Marketplace__UnauthorizedRemoval();\n        }\n\n        if (block.timestamp > offer.updatedAt + TIME_TO_LOCK) {\n            revert Marketplace__OfferNotRemovable();\n        }\n\n        if (\n            block.timestamp > request.updatedAt + TIME_TO_LOCK &&\n            request.lifecycle == RequestLifecycle.ACCEPTED_BY_BUYER\n        ) {\n            revert Marketplace__RequestLocked();\n        }\n        uint indexToRemove;\n        bool found = false;\n\n        for (uint i = 0; i < request.sellerIds.length; i++) {\n            if (request.sellerIds[i] == offer.sellerId) {\n                indexToRemove = i;\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            // Shift all elements after the one to remove left by one position\n            for (\n                uint i = indexToRemove;\n                i < request.sellerIds.length - 1;\n                i++\n            ) {\n                request.sellerIds[i] = request.sellerIds[i + 1];\n            }\n            // Remove the last element (duplicate after shifting)\n            request.sellerIds.pop();\n        }\n\n        // Delete the offer\n        delete offers[_offerId];\n\n        // Emit the event\n        emit OfferRemoved(_offerId, msg.sender);\n    }\n\n    function userStoreCount(address user) public view returns (uint256) {\n        return userStoreIds[user].length;\n    }\n\n    function getRequestImagesLength(\n        uint256 requestId\n    ) public view returns (uint256) {\n        return requests[requestId].images.length;\n    }\n\n    function getRequestImageByIndex(\n        uint256 requestId,\n        uint256 index\n    ) public view returns (string memory) {\n        if (index >= requests[requestId].images.length) {\n            revert Marketplace__IndexOutOfBounds();\n        }\n        return requests[requestId].images[index];\n    }\n\n    function getRequestSellerIdsLength(\n        uint256 requestId\n    ) public view returns (uint256) {\n        return requests[requestId].sellerIds.length;\n    }\n\n    function getRequestSellerIdByIndex(\n        uint256 requestId,\n        uint256 index\n    ) public view returns (uint256) {\n        if (index >= requests[requestId].sellerIds.length) {\n            revert Marketplace__IndexOutOfBounds();\n        }\n        return requests[requestId].sellerIds[index];\n    }\n\n    function getOfferImagesLength(\n        uint256 offerId\n    ) public view returns (uint256) {\n        return offers[offerId].images.length;\n    }\n\n    function getOfferImageByIndex(\n        uint256 offerId,\n        uint256 index\n    ) public view returns (string memory) {\n        if (index >= offers[offerId].images.length) {\n            revert Marketplace__IndexOutOfBounds();\n        }\n        return offers[offerId].images[index];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}